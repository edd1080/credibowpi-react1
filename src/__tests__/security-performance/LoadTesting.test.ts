// Load Testing: Authentication System Load and Stress Tests
import { securityTestUtils, performanceTestUtils } from './setup';
import { BowpiAuthService } from '../../services/BowpiAuthService';
import { BowpiOTPService } from '../../services/bowpi/BowpiOTPService';
import { BowpiHMACService } from '../../services/bowpi/BowpiHMACService';
import { BowpiCryptoService } from '../../services/bowpi/BowpiCryptoService';
import { bowpiSecureStorage } from '../../services/BowpiSecureStorageService';

describe('Authentication Load Testing', () => {
  let authService: BowpiAuthService;
  let otpService: BowpiOTPService;
  let hmacService: BowpiHMACService;
  let cryptoService: BowpiCryptoService;

  beforeEach(() => {
    authService = new BowpiAuthService();
    otpService = new BowpiOTPService();
    hmacService = new BowpiHMACService();
    cryptoService = new BowpiCryptoService();
  });

  describe('Concurrent User Load Testing', () => {
    it('should handle 50 concurrent login attempts', async () => {
      const concurrentUsers = 50;
      const credentials = securityTestUtils.generateCredentials();
      const mockUserData = securityTestUtils.createMockUserData();
      const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');

      // Mock responses for all concurrent requests
      for (let i = 0; i < concurrentUsers; i++) {
        securityTestUtils.mockServerResponse(mockResponse);
      }
      jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);

      const { result, duration } = await performanceTestUtils.measureTime(async () => {
        const loginPromises = Array(concurrentUsers).fill(0).map((_, index) => 
          authService.login({
            ...credentials,
            username: `${credentials.username}_${index}`
          })
        );
        return Promise.all(loginPromises);
      });

      // All logins should succeed
      expect(result.every(r => r.success)).toBe(true);
      
      // Should complete within reasonable time
      expect(duration).toBeLessThan(performanceTestUtils.benchmarks.NETWORK_OPERATION * 2);
      
      // Average time per login should be reasonable
      const averageTimePerLogin = duration / concurrentUsers;
      expect(averageTimePerLogin).toBeLessThan(performanceTestUtils.benchmarks.MEDIUM_OPERATION);
    });

    it('should handle 100 concurrent token validations', async () => {
      const concurrentValidations = 100;
      const mockUserData = securityTestUtils.createMockUserData();
      
      // Setup authenticated state
      const credentials = securityTestUtils.generateCredentials();
      const loginResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');
      securityTestUtils.mockServerResponse(loginResponse);
      jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);
      
      await authService.login(credentials);

      const { result, duration } = await performanceTestUtils.measureTime(async () => {
        const validationPromises = Array(concurrentValidations).fill(0).map(() => 
          authService.isAuthenticated()
        );
        return Promise.all(validationPromises);
      });

      // All validations should succeed
      expect(result.every(isAuth => isAuth === true)).toBe(true);
      
      // Should complete quickly since it's mostly local validation
      expect(duration).toBeLessThan(performanceTestUtils.benchmarks.SLOW_OPERATION);
      
      const averageTimePerValidation = duration / concurrentValidations;
      expect(averageTimePerValidation).toBeLessThan(performanceTestUtils.benchmarks.FAST_OPERATION);
    });

    it('should handle mixed concurrent operations', async () => {
      const operationsPerType = 20;
      const mockUserData = securityTestUtils.createMockUserData();
      const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');

      // Mock responses for all operations
      for (let i = 0; i < operationsPerType * 4; i++) {
        securityTestUtils.mockServerResponse(mockResponse);
      }
      jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);

      const { duration } = await performanceTestUtils.measureTime(async () => {
        const operations = [];\n\n        // Login operations\n        for (let i = 0; i < operationsPerType; i++) {\n          operations.push(\n            authService.login({\n              username: `user_${i}`,\n              password: 'testpassword'\n            })\n          );\n        }\n\n        // Token validation operations\n        for (let i = 0; i < operationsPerType; i++) {\n          operations.push(authService.isAuthenticated());\n        }\n\n        // OTP generation operations\n        for (let i = 0; i < operationsPerType; i++) {\n          operations.push(otpService.generateOTPToken());\n        }\n\n        // HMAC operations\n        for (let i = 0; i < operationsPerType; i++) {\n          operations.push(\n            hmacService.generateDigest(`test-data-${i}`, 'test-secret')\n          );\n        }\n\n        return Promise.all(operations);\n      });\n\n      // Should handle mixed load efficiently\n      expect(duration).toBeLessThan(performanceTestUtils.benchmarks.NETWORK_OPERATION * 3);\n    });\n\n    it('should maintain performance with increasing concurrent users', async () => {\n      const userCounts = [10, 25, 50, 75, 100];\n      const results: { users: number; duration: number; avgPerUser: number }[] = [];\n\n      for (const userCount of userCounts) {\n        const credentials = securityTestUtils.generateCredentials();\n        const mockUserData = securityTestUtils.createMockUserData();\n        const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');\n\n        // Mock responses for current user count\n        for (let i = 0; i < userCount; i++) {\n          securityTestUtils.mockServerResponse(mockResponse);\n        }\n        jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);\n\n        const { duration } = await performanceTestUtils.measureTime(async () => {\n          const loginPromises = Array(userCount).fill(0).map((_, index) => \n            authService.login({\n              ...credentials,\n              username: `${credentials.username}_${index}`\n            })\n          );\n          return Promise.all(loginPromises);\n        });\n\n        const avgPerUser = duration / userCount;\n        results.push({ users: userCount, duration, avgPerUser });\n\n        // Performance should not degrade significantly\n        expect(avgPerUser).toBeLessThan(performanceTestUtils.benchmarks.MEDIUM_OPERATION);\n      }\n\n      // Check that performance scales reasonably\n      for (let i = 1; i < results.length; i++) {\n        const current = results[i];\n        const previous = results[i - 1];\n        \n        // Average time per user should not increase dramatically\n        const performanceRatio = current.avgPerUser / previous.avgPerUser;\n        expect(performanceRatio).toBeLessThan(2); // Should not double\n      }\n    });\n  });\n\n  describe('High-Volume Data Processing', () => {\n    it('should handle large token payloads efficiently', async () => {\n      const payloadSizes = [1, 5, 10, 25, 50]; // KB\n      const results: { size: number; duration: number }[] = [];\n\n      for (const sizeKB of payloadSizes) {\n        const largeProfile = {\n          names: 'John',\n          lastNames: 'Doe',\n          documentType: 'CC',\n          documentNumber: '12345678',\n          phone: '1234567890',\n          address: 'Test Address',\n          largeData: performanceTestUtils.generateLargeData(sizeKB)\n        };\n\n        const mockUserData = securityTestUtils.createMockUserData({\n          userProfile: largeProfile\n        });\n\n        const credentials = securityTestUtils.generateCredentials();\n        const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');\n        \n        securityTestUtils.mockServerResponse(mockResponse);\n        jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);\n\n        const { duration } = await performanceTestUtils.measureTime(() =>\n          authService.login(credentials)\n        );\n\n        results.push({ size: sizeKB, duration });\n\n        // Should handle large payloads within reasonable time\n        const expectedMaxTime = performanceTestUtils.benchmarks.NETWORK_OPERATION + (sizeKB * 20);\n        expect(duration).toBeLessThan(expectedMaxTime);\n      }\n\n      // Performance should scale reasonably with payload size\n      for (let i = 1; i < results.length; i++) {\n        const current = results[i];\n        const previous = results[i - 1];\n        \n        // Duration should not increase exponentially\n        const scalingFactor = current.duration / previous.duration;\n        expect(scalingFactor).toBeLessThan(3);\n      }\n    });\n\n    it('should process high-volume HMAC operations', async () => {\n      const operationCounts = [100, 500, 1000, 2000];\n      const testData = 'test data for HMAC performance';\n      const secret = 'test-secret-key';\n\n      for (const operationCount of operationCounts) {\n        const { duration } = await performanceTestUtils.measureTime(async () => {\n          const promises = Array(operationCount).fill(0).map((_, index) =>\n            hmacService.generateDigest(`${testData}-${index}`, secret)\n          );\n          await Promise.all(promises);\n        });\n\n        const averagePerOperation = duration / operationCount;\n        expect(averagePerOperation).toBeLessThan(performanceTestUtils.benchmarks.FAST_OPERATION);\n\n        // Total time should scale reasonably\n        const expectedMaxTime = operationCount * 10; // 10ms per operation max\n        expect(duration).toBeLessThan(expectedMaxTime);\n      }\n    });\n\n    it('should handle bulk storage operations', async () => {\n      const itemCounts = [50, 100, 200, 500];\n      const testData = 'bulk storage test data';\n\n      for (const itemCount of itemCounts) {\n        // Test bulk storage\n        const { duration: storeDuration } = await performanceTestUtils.measureTime(async () => {\n          const storePromises = Array(itemCount).fill(0).map((_, index) =>\n            bowpiSecureStorage.secureStore(`bulk-item-${index}`, `${testData}-${index}`)\n          );\n          await Promise.all(storePromises);\n        });\n\n        // Test bulk retrieval\n        const { duration: retrieveDuration } = await performanceTestUtils.measureTime(async () => {\n          const retrievePromises = Array(itemCount).fill(0).map((_, index) =>\n            bowpiSecureStorage.secureRetrieve(`bulk-item-${index}`)\n          );\n          await Promise.all(retrievePromises);\n        });\n\n        const avgStoreTime = storeDuration / itemCount;\n        const avgRetrieveTime = retrieveDuration / itemCount;\n\n        expect(avgStoreTime).toBeLessThan(performanceTestUtils.benchmarks.MEDIUM_OPERATION);\n        expect(avgRetrieveTime).toBeLessThan(performanceTestUtils.benchmarks.MEDIUM_OPERATION);\n      }\n    });\n\n    it('should handle rapid OTP generation', async () => {\n      const generationCounts = [100, 500, 1000];\n\n      for (const count of generationCounts) {\n        const { result, duration } = await performanceTestUtils.measureTime(async () => {\n          const promises = Array(count).fill(0).map(() => otpService.generateOTPToken());\n          return Promise.all(promises);\n        });\n\n        // All tokens should be generated successfully\n        expect(result.length).toBe(count);\n        expect(result.every(token => typeof token === 'string' && token.length > 0)).toBe(true);\n\n        // All tokens should be unique\n        const uniqueTokens = new Set(result);\n        expect(uniqueTokens.size).toBe(count);\n\n        // Performance should be reasonable\n        const averagePerGeneration = duration / count;\n        expect(averagePerGeneration).toBeLessThan(performanceTestUtils.benchmarks.FAST_OPERATION);\n      }\n    });\n  });\n\n  describe('Memory and Resource Stress Testing', () => {\n    it('should handle memory-intensive authentication operations', async () => {\n      const startMemory = performanceTestUtils.measureMemory();\n      const operationCount = 200;\n      const credentials = securityTestUtils.generateCredentials();\n      \n      // Create large user profiles to stress memory\n      const largeProfile = {\n        names: 'John',\n        lastNames: 'Doe',\n        documentType: 'CC',\n        documentNumber: '12345678',\n        phone: '1234567890',\n        address: 'Test Address',\n        largeData: performanceTestUtils.generateLargeData(10) // 10KB per user\n      };\n\n      const mockUserData = securityTestUtils.createMockUserData({\n        userProfile: largeProfile\n      });\n\n      // Perform many authentication operations\n      for (let i = 0; i < operationCount; i++) {\n        const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');\n        securityTestUtils.mockServerResponse(mockResponse);\n        jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);\n\n        const result = await authService.login({\n          ...credentials,\n          username: `${credentials.username}_${i}`\n        });\n        expect(result.success).toBe(true);\n\n        // Logout to clean up\n        const logoutResponse = securityTestUtils.createMockBowpiResponse(null);\n        securityTestUtils.mockServerResponse(logoutResponse);\n        await authService.logout();\n      }\n\n      const endMemory = performanceTestUtils.measureMemory();\n      const memoryIncrease = endMemory.heapUsed - startMemory.heapUsed;\n\n      // Memory increase should be reasonable (less than 50MB)\n      expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024);\n    });\n\n    it('should handle resource exhaustion gracefully', async () => {\n      const cleanup = performanceTestUtils.createMemoryPressure(200); // 200MB pressure\n      \n      try {\n        const credentials = securityTestUtils.generateCredentials();\n        const mockUserData = securityTestUtils.createMockUserData();\n        const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');\n\n        securityTestUtils.mockServerResponse(mockResponse);\n        jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);\n\n        // Should still be able to authenticate under memory pressure\n        const { result, duration } = await performanceTestUtils.measureTime(() =>\n          authService.login(credentials)\n        );\n\n        expect(result.success).toBe(true);\n        // May be slower under pressure but should still complete\n        expect(duration).toBeLessThan(performanceTestUtils.benchmarks.NETWORK_OPERATION * 5);\n      } finally {\n        cleanup();\n      }\n    });\n\n    it('should handle CPU-intensive operations under load', async () => {\n      const credentials = securityTestUtils.generateCredentials();\n      const mockUserData = securityTestUtils.createMockUserData();\n      const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');\n\n      securityTestUtils.mockServerResponse(mockResponse);\n      jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);\n\n      // Start CPU load in background\n      const cpuLoadPromise = new Promise<void>(resolve => {\n        setTimeout(() => {\n          performanceTestUtils.simulateCPULoad(2000); // 2 seconds of CPU load\n          resolve();\n        }, 100);\n      });\n\n      // Perform authentication while CPU is under load\n      const authPromise = performanceTestUtils.measureTime(() =>\n        authService.login(credentials)\n      );\n\n      const [{ result, duration }] = await Promise.all([authPromise, cpuLoadPromise]);\n\n      expect(result.success).toBe(true);\n      // Should complete even under CPU load, though potentially slower\n      expect(duration).toBeLessThan(performanceTestUtils.benchmarks.NETWORK_OPERATION * 3);\n    });\n\n    it('should handle storage pressure efficiently', async () => {\n      const itemCount = 1000;\n      const testData = 'storage pressure test data';\n\n      // Fill storage with many items\n      const storePromises = Array(itemCount).fill(0).map((_, index) =>\n        bowpiSecureStorage.secureStore(`pressure-item-${index}`, `${testData}-${index}`)\n      );\n      \n      const { duration: storeDuration } = await performanceTestUtils.measureTime(() =>\n        Promise.all(storePromises)\n      );\n\n      // Should handle bulk storage reasonably\n      expect(storeDuration).toBeLessThan(performanceTestUtils.benchmarks.SLOW_OPERATION * 5);\n\n      // Test authentication performance with full storage\n      const credentials = securityTestUtils.generateCredentials();\n      const mockUserData = securityTestUtils.createMockUserData();\n      const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');\n\n      securityTestUtils.mockServerResponse(mockResponse);\n      jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);\n\n      const { result, duration: authDuration } = await performanceTestUtils.measureTime(() =>\n        authService.login(credentials)\n      );\n\n      expect(result.success).toBe(true);\n      // Authentication should not be significantly affected by storage pressure\n      expect(authDuration).toBeLessThan(performanceTestUtils.benchmarks.NETWORK_OPERATION * 2);\n    });\n  });\n\n  describe('Network Stress Testing', () => {\n    it('should handle network latency variations', async () => {\n      const latencies = [100, 500, 1000, 2000, 3000]; // ms\n      const credentials = securityTestUtils.generateCredentials();\n      const mockUserData = securityTestUtils.createMockUserData();\n      const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');\n\n      for (const latency of latencies) {\n        // Mock network response with specific latency\n        (global.fetch as jest.Mock).mockImplementationOnce(() =>\n          new Promise(resolve =>\n            setTimeout(() => resolve({\n              ok: true,\n              status: 200,\n              json: () => Promise.resolve(mockResponse)\n            }), latency)\n          )\n        );\n\n        jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);\n\n        const { result, duration } = await performanceTestUtils.measureTime(() =>\n          authService.login(credentials)\n        );\n\n        expect(result.success).toBe(true);\n        // Should wait for network response plus processing time\n        expect(duration).toBeGreaterThan(latency * 0.9); // Allow 10% variance\n        expect(duration).toBeLessThan(latency + performanceTestUtils.benchmarks.MEDIUM_OPERATION);\n      }\n    });\n\n    it('should handle network interruptions with retries', async () => {\n      const credentials = securityTestUtils.generateCredentials();\n      const mockUserData = securityTestUtils.createMockUserData();\n      const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');\n\n      let attemptCount = 0;\n      (global.fetch as jest.Mock).mockImplementation(() => {\n        attemptCount++;\n        if (attemptCount <= 3) {\n          return Promise.reject(new Error('Network error'));\n        }\n        return Promise.resolve({\n          ok: true,\n          status: 200,\n          json: () => Promise.resolve(mockResponse)\n        });\n      });\n\n      jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);\n\n      const { result, duration } = await performanceTestUtils.measureTime(() =>\n        authService.login(credentials)\n      );\n\n      expect(result.success).toBe(true);\n      expect(attemptCount).toBeGreaterThan(3); // Should have retried\n      // Should complete within reasonable time even with retries\n      expect(duration).toBeLessThan(performanceTestUtils.benchmarks.NETWORK_OPERATION * 4);\n    });\n\n    it('should handle concurrent network requests efficiently', async () => {\n      const concurrentRequests = 100;\n      const credentials = securityTestUtils.generateCredentials();\n      const mockUserData = securityTestUtils.createMockUserData();\n      const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');\n\n      // Mock responses for all concurrent requests\n      for (let i = 0; i < concurrentRequests; i++) {\n        securityTestUtils.mockServerResponse(mockResponse);\n      }\n      jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);\n\n      const { result, duration } = await performanceTestUtils.measureTime(async () => {\n        const promises = Array(concurrentRequests).fill(0).map((_, index) =>\n          authService.login({\n            ...credentials,\n            username: `${credentials.username}_${index}`\n          })\n        );\n        return Promise.all(promises);\n      });\n\n      // All requests should succeed\n      expect(result.every(r => r.success)).toBe(true);\n      \n      // Should handle concurrent requests efficiently\n      expect(duration).toBeLessThan(performanceTestUtils.benchmarks.NETWORK_OPERATION * 3);\n      \n      const averageTimePerRequest = duration / concurrentRequests;\n      expect(averageTimePerRequest).toBeLessThan(performanceTestUtils.benchmarks.MEDIUM_OPERATION);\n    });\n\n    it('should handle bandwidth limitations', async () => {\n      const credentials = securityTestUtils.generateCredentials();\n      const largeProfile = {\n        names: 'John',\n        lastNames: 'Doe',\n        documentType: 'CC',\n        documentNumber: '12345678',\n        phone: '1234567890',\n        address: 'Test Address',\n        largeData: performanceTestUtils.generateLargeData(100) // 100KB payload\n      };\n\n      const mockUserData = securityTestUtils.createMockUserData({\n        userProfile: largeProfile\n      });\n      const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');\n\n      // Simulate slow network (bandwidth limitation)\n      (global.fetch as jest.Mock).mockImplementationOnce(() =>\n        new Promise(resolve =>\n          setTimeout(() => resolve({\n            ok: true,\n            status: 200,\n            json: () => Promise.resolve(mockResponse)\n          }), 2000) // 2 second delay to simulate slow network\n        )\n      );\n\n      jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);\n\n      const { result, duration } = await performanceTestUtils.measureTime(() =>\n        authService.login(credentials)\n      );\n\n      expect(result.success).toBe(true);\n      // Should handle large payloads over slow networks\n      expect(duration).toBeGreaterThan(1900); // Should wait for slow response\n      expect(duration).toBeLessThan(performanceTestUtils.benchmarks.NETWORK_OPERATION * 2);\n    });\n  });\n\n  describe('Long-Running Stress Tests', () => {\n    it('should maintain performance over extended periods', async () => {\n      const testDurationMinutes = 1; // 1 minute test\n      const operationInterval = 100; // Operation every 100ms\n      const startTime = Date.now();\n      const endTime = startTime + (testDurationMinutes * 60 * 1000);\n      \n      const credentials = securityTestUtils.generateCredentials();\n      const mockUserData = securityTestUtils.createMockUserData();\n      const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');\n      \n      const operationTimes: number[] = [];\n      let operationCount = 0;\n\n      while (Date.now() < endTime) {\n        securityTestUtils.mockServerResponse(mockResponse);\n        jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);\n\n        const { duration } = await performanceTestUtils.measureTime(() =>\n          authService.login({\n            ...credentials,\n            username: `${credentials.username}_${operationCount}`\n          })\n        );\n\n        operationTimes.push(duration);\n        operationCount++;\n\n        // Wait before next operation\n        await performanceTestUtils.waitFor(operationInterval);\n      }\n\n      // Should have performed multiple operations\n      expect(operationCount).toBeGreaterThan(10);\n\n      // Calculate performance statistics\n      const averageTime = operationTimes.reduce((a, b) => a + b) / operationTimes.length;\n      const maxTime = Math.max(...operationTimes);\n      const minTime = Math.min(...operationTimes);\n\n      // Performance should remain consistent\n      expect(averageTime).toBeLessThan(performanceTestUtils.benchmarks.NETWORK_OPERATION);\n      expect(maxTime).toBeLessThan(performanceTestUtils.benchmarks.NETWORK_OPERATION * 2);\n      \n      // Performance should not degrade significantly over time\n      const firstHalf = operationTimes.slice(0, Math.floor(operationTimes.length / 2));\n      const secondHalf = operationTimes.slice(Math.floor(operationTimes.length / 2));\n      \n      const firstHalfAvg = firstHalf.reduce((a, b) => a + b) / firstHalf.length;\n      const secondHalfAvg = secondHalf.reduce((a, b) => a + b) / secondHalf.length;\n      \n      const performanceDegradation = secondHalfAvg / firstHalfAvg;\n      expect(performanceDegradation).toBeLessThan(1.5); // Should not degrade by more than 50%\n    });\n\n    it('should handle memory cleanup over time', async () => {\n      const iterations = 100;\n      const credentials = securityTestUtils.generateCredentials();\n      const mockUserData = securityTestUtils.createMockUserData();\n      const mockResponse = securityTestUtils.createMockBowpiResponse('encrypted-jwt-token');\n      \n      const memoryMeasurements: number[] = [];\n\n      for (let i = 0; i < iterations; i++) {\n        securityTestUtils.mockServerResponse(mockResponse);\n        jest.spyOn(cryptoService, 'decryptToken').mockResolvedValue(mockUserData);\n\n        await authService.login({\n          ...credentials,\n          username: `${credentials.username}_${i}`\n        });\n\n        // Logout to trigger cleanup\n        const logoutResponse = securityTestUtils.createMockBowpiResponse(null);\n        securityTestUtils.mockServerResponse(logoutResponse);\n        await authService.logout();\n\n        // Measure memory every 10 iterations\n        if (i % 10 === 0) {\n          const memory = performanceTestUtils.measureMemory();\n          memoryMeasurements.push(memory.heapUsed);\n        }\n      }\n\n      // Memory should not continuously increase\n      const firstMeasurement = memoryMeasurements[0];\n      const lastMeasurement = memoryMeasurements[memoryMeasurements.length - 1];\n      const memoryIncrease = lastMeasurement - firstMeasurement;\n      \n      // Should not have significant memory leaks\n      expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // Less than 50MB increase\n    });\n  });\n});"