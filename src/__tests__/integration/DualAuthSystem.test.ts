// Dual Authentication System Integration Tests
// End-to-end tests for the complete dual authentication system

import AsyncStorage from '@react-native-async-storage/async-storage';
import { AuthStoreManager } from '../../services/AuthStoreManager';
import { AuthProviderFactory } from '../../services/auth/AuthProviderFactory';
import { AuthConfigurationService } from '../../services/auth/AuthConfiguration';
import { LegacyAuthProvider } from '../../services/auth/providers/LegacyAuthProvider';
import { BowpiAuthProvider } from '../../services/auth/providers/BowpiAuthProvider';
import { AuthType } from '../../types/auth-providers';

// Mock AsyncStorage
jest.mock('@react-native-async-storage/async-storage', () => ({
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
}));\n\n// Mock BowpiAuthService (external dependency)\njest.mock('../../Authentication/BowpiAuthAdapter', () => ({\n  BowpiAuthService: {\n    login: jest.fn(),\n    logout: jest.fn(),\n    isAuthenticated: jest.fn(),\n    getCurrentUser: jest.fn(),\n    initialize: jest.fn(),\n  },\n}));\n\n// Mock console to reduce test noise\nconst mockConsole = {\n  log: jest.fn(),\n  error: jest.fn(),\n  warn: jest.fn(),\n};\nglobal.console = mockConsole as any;\n\ndescribe('Dual Authentication System - Integration Tests', () => {\n  let authStoreManager: AuthStoreManager;\n  let authProviderFactory: AuthProviderFactory;\n  let authConfigService: AuthConfigurationService;\n  const mockAsyncStorage = AsyncStorage as jest.Mocked<typeof AsyncStorage>;\n\n  beforeEach(async () => {\n    jest.clearAllMocks();\n    \n    // Reset singletons\n    (AuthStoreManager as any).instance = undefined;\n    (AuthProviderFactory as any).instance = undefined;\n    (AuthConfigurationService as any).instance = undefined;\n    \n    // Mock AsyncStorage responses\n    mockAsyncStorage.getItem.mockResolvedValue(null);\n    mockAsyncStorage.setItem.mockResolvedValue();\n    mockAsyncStorage.removeItem.mockResolvedValue();\n    \n    // Initialize services\n    authConfigService = AuthConfigurationService.getInstance();\n    authProviderFactory = AuthProviderFactory.getInstance();\n    authStoreManager = AuthStoreManager.getInstance();\n    \n    // Initialize configuration\n    await authConfigService.initialize();\n  });\n\n  describe('Complete Authentication Flow', () => {\n    it('should perform complete login flow with Legacy provider', async () => {\n      // Set up Legacy provider configuration\n      await authConfigService.setAuthType(AuthType.LEGACY);\n      await authConfigService.updateLegacyConfig({\n        mockDelay: 100,\n        allowedUsers: ['test@example.com'],\n        simulateNetworkErrors: false,\n        offlineMode: true,\n        sessionDuration: 3600000,\n        enableDebugLogging: false,\n        mockUserRoles: {\n          'test@example.com': 'agent'\n        }\n      });\n\n      // Perform login\n      const loginResult = await authStoreManager.login('test@example.com', 'password123');\n      \n      expect(loginResult.success).toBe(true);\n      expect(loginResult.provider).toBe(AuthType.LEGACY);\n      expect(loginResult.userData?.email).toBe('test@example.com');\n      expect(loginResult.userData?.role).toBe('agent');\n      \n      // Verify authentication state\n      const isAuthenticated = await authStoreManager.isAuthenticated();\n      expect(isAuthenticated).toBe(true);\n      \n      // Verify current user\n      const currentUser = await authStoreManager.getCurrentUser();\n      expect(currentUser?.email).toBe('test@example.com');\n      \n      // Perform logout\n      await authStoreManager.logout();\n      \n      // Verify logout state\n      expect(await authStoreManager.isAuthenticated()).toBe(false);\n      expect(await authStoreManager.getCurrentUser()).toBeNull();\n    });\n\n    it('should handle authentication failure gracefully', async () => {\n      await authConfigService.setAuthType(AuthType.LEGACY);\n      await authConfigService.updateLegacyConfig({\n        allowedUsers: ['allowed@example.com'], // Different user\n        mockDelay: 100\n      });\n\n      const loginResult = await authStoreManager.login('notallowed@example.com', 'password123');\n      \n      expect(loginResult.success).toBe(false);\n      expect(loginResult.message).toContain('Invalid email or password');\n      expect(loginResult.provider).toBe(AuthType.LEGACY);\n      \n      // Should not be authenticated\n      expect(await authStoreManager.isAuthenticated()).toBe(false);\n    });\n  });\n\n  describe('Provider Switching Integration', () => {\n    it('should switch from Legacy to Bowpi provider', async () => {\n      // Start with Legacy\n      await authConfigService.setAuthType(AuthType.LEGACY);\n      await authConfigService.updateLegacyConfig({\n        allowedUsers: ['test@example.com'],\n        mockDelay: 100\n      });\n      \n      // Login with Legacy\n      const legacyLogin = await authStoreManager.login('test@example.com', 'password123');\n      expect(legacyLogin.success).toBe(true);\n      expect(legacyLogin.provider).toBe(AuthType.LEGACY);\n      \n      // Validate switch\n      const validation = await authStoreManager.validateProviderSwitch(AuthType.BOWPI);\n      expect(validation.canSwitch).toBe(true);\n      expect(validation.warnings).toContain('Current user will be logged out during switch');\n      \n      // Perform switch\n      const switchResult = await authStoreManager.switchAuthProvider(AuthType.BOWPI);\n      expect(switchResult.success).toBe(true);\n      expect(switchResult.previousType).toBe(AuthType.LEGACY);\n      expect(switchResult.newType).toBe(AuthType.BOWPI);\n      \n      // Verify new provider is active\n      expect(authStoreManager.getCurrentAuthType()).toBe(AuthType.BOWPI);\n      \n      // Should be logged out after switch\n      expect(await authStoreManager.isAuthenticated()).toBe(false);\n    });\n\n    it('should prevent switching when runtime switching is disabled', async () => {\n      await authConfigService.setAuthType(AuthType.LEGACY);\n      \n      // Disable runtime switching\n      const config = authConfigService.getConfiguration();\n      await authConfigService.updateConfiguration({\n        ...config,\n        allowRuntimeSwitch: false\n      });\n      \n      // Attempt switch\n      const switchResult = await authStoreManager.switchAuthProvider(AuthType.BOWPI);\n      \n      expect(switchResult.success).toBe(false);\n      expect(switchResult.message).toContain('Runtime provider switching is not allowed');\n      \n      // Should still be using Legacy\n      expect(authStoreManager.getCurrentAuthType()).toBe(AuthType.LEGACY);\n    });\n\n    it('should handle switch validation failures', async () => {\n      await authConfigService.setAuthType(AuthType.LEGACY);\n      \n      // Mock unhealthy target provider\n      const mockProvider = await authProviderFactory.createProvider(AuthType.BOWPI);\n      jest.spyOn(mockProvider, 'healthCheck').mockResolvedValue({\n        isHealthy: false,\n        status: 'error',\n        message: 'Provider is unhealthy',\n        lastCheck: new Date(),\n        details: {}\n      });\n      \n      const validation = await authStoreManager.validateProviderSwitch(AuthType.BOWPI);\n      \n      expect(validation.canSwitch).toBe(false);\n      expect(validation.reason).toContain('Target provider is not healthy');\n      expect(validation.requirements.targetProviderHealthy).toBe(false);\n    });\n  });\n\n  describe('Auto-Switch on Failure', () => {\n    it('should auto-switch to fallback provider on authentication failure', async () => {\n      // Configure auto-switch\n      await authConfigService.setAuthType(AuthType.BOWPI);\n      const config = authConfigService.getConfiguration();\n      await authConfigService.updateConfiguration({\n        ...config,\n        autoSwitchOnFailure: true,\n        fallbackType: AuthType.LEGACY\n      });\n      \n      // Configure Legacy as fallback\n      await authConfigService.updateLegacyConfig({\n        allowedUsers: ['test@example.com'],\n        mockDelay: 100\n      });\n      \n      // Mock Bowpi provider failure\n      const bowpiProvider = await authProviderFactory.createProvider(AuthType.BOWPI);\n      jest.spyOn(bowpiProvider, 'login').mockResolvedValue({\n        success: false,\n        message: 'Network connection failed',\n        error: new Error('Network error'),\n        provider: AuthType.BOWPI,\n        duration: 1000\n      });\n      \n      // Attempt login - should auto-switch to Legacy\n      const loginResult = await authStoreManager.login('test@example.com', 'password123');\n      \n      expect(loginResult.success).toBe(true);\n      expect(loginResult.provider).toBe(AuthType.LEGACY); // Switched to fallback\n      expect(authStoreManager.getCurrentAuthType()).toBe(AuthType.LEGACY);\n    });\n\n    it('should not auto-switch when disabled', async () => {\n      // Configure without auto-switch\n      await authConfigService.setAuthType(AuthType.BOWPI);\n      const config = authConfigService.getConfiguration();\n      await authConfigService.updateConfiguration({\n        ...config,\n        autoSwitchOnFailure: false\n      });\n      \n      // Mock Bowpi provider failure\n      const bowpiProvider = await authProviderFactory.createProvider(AuthType.BOWPI);\n      jest.spyOn(bowpiProvider, 'login').mockResolvedValue({\n        success: false,\n        message: 'Network connection failed',\n        error: new Error('Network error'),\n        provider: AuthType.BOWPI,\n        duration: 1000\n      });\n      \n      // Attempt login - should fail without switching\n      const loginResult = await authStoreManager.login('test@example.com', 'password123');\n      \n      expect(loginResult.success).toBe(false);\n      expect(loginResult.provider).toBe(AuthType.BOWPI); // No switch occurred\n      expect(authStoreManager.getCurrentAuthType()).toBe(AuthType.BOWPI);\n    });\n  });\n\n  describe('Configuration Persistence', () => {\n    it('should persist configuration changes', async () => {\n      // Change configuration\n      await authConfigService.setAuthType(AuthType.LEGACY);\n      await authConfigService.updateLegacyConfig({\n        mockDelay: 2000,\n        allowedUsers: ['custom@example.com']\n      });\n      \n      // Verify AsyncStorage was called\n      expect(mockAsyncStorage.setItem).toHaveBeenCalledWith(\n        'auth_configuration',\n        expect.stringContaining('\"currentType\":\"legacy\"')\n      );\n      expect(mockAsyncStorage.setItem).toHaveBeenCalledWith(\n        'auth_configuration',\n        expect.stringContaining('\"mockDelay\":2000')\n      );\n    });\n\n    it('should load persisted configuration on initialization', async () => {\n      const persistedConfig = {\n        currentType: AuthType.LEGACY,\n        allowRuntimeSwitch: false,\n        legacy: {\n          mockDelay: 1500,\n          allowedUsers: ['persisted@example.com']\n        }\n      };\n      \n      mockAsyncStorage.getItem.mockImplementation((key) => {\n        if (key === 'auth_configuration') {\n          return Promise.resolve(JSON.stringify(persistedConfig));\n        }\n        return Promise.resolve(null);\n      });\n      \n      // Create new configuration service instance\n      (AuthConfigurationService as any).instance = undefined;\n      const newConfigService = AuthConfigurationService.getInstance();\n      await newConfigService.initialize();\n      \n      const config = newConfigService.getConfiguration();\n      expect(config.currentType).toBe(AuthType.LEGACY);\n      expect(config.allowRuntimeSwitch).toBe(false);\n      expect(config.legacy.mockDelay).toBe(1500);\n      expect(config.legacy.allowedUsers).toContain('persisted@example.com');\n    });\n  });\n\n  describe('Health Checks and Monitoring', () => {\n    it('should perform health checks on providers', async () => {\n      await authConfigService.setAuthType(AuthType.LEGACY);\n      \n      const provider = await authProviderFactory.getCurrentProvider();\n      expect(provider).toBeDefined();\n      \n      const health = await provider!.healthCheck();\n      expect(health.isHealthy).toBe(true);\n      expect(health.status).toBe('healthy');\n      expect(health.lastCheck).toBeInstanceOf(Date);\n    });\n\n    it('should track provider metrics', async () => {\n      await authConfigService.setAuthType(AuthType.LEGACY);\n      await authConfigService.updateLegacyConfig({\n        allowedUsers: ['test@example.com'],\n        mockDelay: 100\n      });\n      \n      // Perform some operations to generate metrics\n      await authStoreManager.login('test@example.com', 'password123');\n      await authStoreManager.login('invalid@example.com', 'password123');\n      await authStoreManager.logout();\n      \n      const metricsResult = await authStoreManager.getProviderMetrics();\n      \n      expect(metricsResult.currentProvider).toBe(AuthType.LEGACY);\n      expect(metricsResult.metrics.totalLoginAttempts).toBe(2);\n      expect(metricsResult.metrics.successfulLogins).toBe(1);\n      expect(metricsResult.metrics.failedLogins).toBe(1);\n      expect(metricsResult.metrics.successRate).toBe(0.5);\n    });\n  });\n\n  describe('Error Handling and Recovery', () => {\n    it('should handle AsyncStorage failures gracefully', async () => {\n      mockAsyncStorage.setItem.mockRejectedValue(new Error('Storage full'));\n      \n      // Should still work but log error\n      await expect(\n        authConfigService.setAuthType(AuthType.LEGACY)\n      ).rejects.toThrow('Storage full');\n      \n      // Configuration should rollback\n      expect(authConfigService.getCurrentAuthType()).toBe(AuthType.BOWPI); // Default\n    });\n\n    it('should recover from provider initialization failures', async () => {\n      // Mock provider initialization failure\n      const originalCreateProvider = authProviderFactory.createProvider;\n      jest.spyOn(authProviderFactory, 'createProvider')\n        .mockRejectedValueOnce(new Error('Init failed'))\n        .mockImplementation(originalCreateProvider.bind(authProviderFactory));\n      \n      // First attempt should fail\n      await expect(\n        authStoreManager.login('test@example.com', 'password123')\n      ).rejects.toThrow('Init failed');\n      \n      // Second attempt should succeed\n      await authConfigService.updateLegacyConfig({\n        allowedUsers: ['test@example.com'],\n        mockDelay: 100\n      });\n      \n      const result = await authStoreManager.login('test@example.com', 'password123');\n      expect(result.success).toBe(true);\n    });\n\n    it('should handle corrupted configuration data', async () => {\n      mockAsyncStorage.getItem.mockResolvedValue('invalid-json-data');\n      \n      // Should initialize with defaults despite corrupted data\n      (AuthConfigurationService as any).instance = undefined;\n      const newConfigService = AuthConfigurationService.getInstance();\n      await newConfigService.initialize();\n      \n      const config = newConfigService.getConfiguration();\n      expect(config.currentType).toBe(AuthType.BOWPI); // Default\n    });\n  });\n\n  describe('Debug and Development Support', () => {\n    it('should provide comprehensive debug information', async () => {\n      await authConfigService.setAuthType(AuthType.LEGACY);\n      await authConfigService.updateLegacyConfig({\n        allowedUsers: ['test@example.com'],\n        mockDelay: 100\n      });\n      \n      await authStoreManager.login('test@example.com', 'password123');\n      \n      const debugInfo = await authStoreManager.getDebugInfo();\n      \n      expect(debugInfo.currentAuthType).toBe(AuthType.LEGACY);\n      expect(debugInfo.isAuthenticated).toBe(true);\n      expect(debugInfo.currentUser?.email).toBe('test@example.com');\n      expect(debugInfo.providerFactory).toBeDefined();\n      expect(debugInfo.storeManagerInitialized).toBe(true);\n      expect(debugInfo.lastOperation).toBeDefined();\n    });\n\n    it('should provide factory debug information', () => {\n      const factoryDebug = authProviderFactory.getDebugInfo();\n      \n      expect(factoryDebug.factoryInitialized).toBe(true);\n      expect(factoryDebug.totalProvidersCreated).toBeGreaterThanOrEqual(0);\n      expect(factoryDebug.cachedProviders).toBeInstanceOf(Array);\n    });\n\n    it('should provide configuration debug information', () => {\n      const configDebug = authConfigService.getDebugInfo();\n      \n      expect(configDebug.isInitialized).toBe(true);\n      expect(configDebug.currentConfig).toBeDefined();\n      expect(configDebug.listenerCount).toBeGreaterThanOrEqual(0);\n      expect(configDebug.environmentOverrides).toBeInstanceOf(Array);\n    });\n  });\n\n  describe('Cleanup and Resource Management', () => {\n    it('should cleanup all resources properly', async () => {\n      // Create providers and perform operations\n      await authConfigService.setAuthType(AuthType.LEGACY);\n      await authStoreManager.login('test@example.com', 'password123');\n      \n      // Switch providers to create multiple instances\n      await authStoreManager.switchAuthProvider(AuthType.BOWPI);\n      \n      // Cleanup all resources\n      await authProviderFactory.cleanup();\n      \n      // Verify cleanup\n      const factoryDebug = authProviderFactory.getDebugInfo();\n      expect(factoryDebug.cachedProviders).toHaveLength(0);\n    });\n\n    it('should handle cleanup errors gracefully', async () => {\n      await authConfigService.setAuthType(AuthType.LEGACY);\n      const provider = await authProviderFactory.getCurrentProvider();\n      \n      // Mock cleanup failure\n      jest.spyOn(provider!, 'cleanup').mockRejectedValue(new Error('Cleanup failed'));\n      \n      // Should not throw\n      await expect(authProviderFactory.cleanup()).resolves.not.toThrow();\n      \n      // Should log error\n      expect(mockConsole.error).toHaveBeenCalledWith(\n        expect.stringContaining('Error cleaning up provider'),\n        expect.any(Error)\n      );\n    });\n  });\n});