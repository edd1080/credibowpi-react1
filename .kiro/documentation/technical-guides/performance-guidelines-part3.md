## UI Performance

### React Native UI Optimization

```typescript
// Optimizaciones específicas de UI para React Native
export class UIPerformanceOptimizer {
  private static readonly UI_CONFIG = {\n    ANIMATION_DURATION: {\n      FAST: 200,\n      NORMAL: 300,\n      SLOW: 500\n    },\n    \n    SCROLL_OPTIMIZATION: {\n      THROTTLE_DELAY: 16,        // 60 FPS\n      DEBOUNCE_DELAY: 100,       // Para búsquedas\n      VIRTUALIZATION_THRESHOLD: 50 // Virtualizar listas > 50 items\n    },\n    \n    RENDER_OPTIMIZATION: {\n      MAX_RENDER_BATCH: 10,\n      RENDER_TIMEOUT: 16,\n      PRIORITY_THRESHOLD: 5\n    }\n  };\n  \n  // Optimizar FlatList para mejor rendimiento\n  static getOptimizedFlatListProps<T>(data: T[], itemHeight?: number): Partial<FlatListProps<T>> {\n    const shouldVirtualize = data.length > this.UI_CONFIG.SCROLL_OPTIMIZATION.VIRTUALIZATION_THRESHOLD;\n    \n    const baseProps: Partial<FlatListProps<T>> = {\n      removeClippedSubviews: true,\n      maxToRenderPerBatch: this.UI_CONFIG.RENDER_OPTIMIZATION.MAX_RENDER_BATCH,\n      updateCellsBatchingPeriod: 50,\n      initialNumToRender: 10,\n      windowSize: shouldVirtualize ? 5 : 10,\n      scrollEventThrottle: this.UI_CONFIG.SCROLL_OPTIMIZATION.THROTTLE_DELAY,\n      \n      // Optimización de keys\n      keyExtractor: (item: any, index: number) => {\n        return item.id ? item.id.toString() : index.toString();\n      }\n    };\n    \n    // Agregar getItemLayout si se conoce la altura\n    if (itemHeight) {\n      baseProps.getItemLayout = (data, index) => ({\n        length: itemHeight,\n        offset: itemHeight * index,\n        index\n      });\n    }\n    \n    return baseProps;\n  }\n  \n  // Hook optimizado para scroll\n  static useOptimizedScroll(onScroll?: (event: any) => void) {\n    const scrollHandler = useCallback(\n      throttle((event: any) => {\n        onScroll?.(event);\n      }, this.UI_CONFIG.SCROLL_OPTIMIZATION.THROTTLE_DELAY),\n      [onScroll]\n    );\n    \n    return scrollHandler;\n  }\n  \n  // Hook para búsqueda con debounce\n  static useOptimizedSearch(onSearch: (query: string) => void, delay?: number) {\n    const [searchQuery, setSearchQuery] = useState('');\n    \n    const debouncedSearch = useCallback(\n      debounce((query: string) => {\n        onSearch(query);\n      }, delay || this.UI_CONFIG.SCROLL_OPTIMIZATION.DEBOUNCE_DELAY),\n      [onSearch]\n    );\n    \n    useEffect(() => {\n      debouncedSearch(searchQuery);\n    }, [searchQuery, debouncedSearch]);\n    \n    return [searchQuery, setSearchQuery] as const;\n  }\n  \n  // Componente optimizado para imágenes\n  static createOptimizedImage = React.memo<ImageProps>(({ source, style, ...props }) => {\n    const [imageLoaded, setImageLoaded] = useState(false);\n    const [error, setError] = useState(false);\n    \n    const handleLoad = useCallback(() => {\n      setImageLoaded(true);\n    }, []);\n    \n    const handleError = useCallback(() => {\n      setError(true);\n    }, []);\n    \n    if (error) {\n      return (\n        <View style={[style, { backgroundColor: '#f0f0f0', justifyContent: 'center', alignItems: 'center' }]}>\n          <Text style={{ color: '#999', fontSize: 12 }}>Error al cargar imagen</Text>\n        </View>\n      );\n    }\n    \n    return (\n      <View style={style}>\n        <Image\n          source={source}\n          style={StyleSheet.absoluteFillObject}\n          onLoad={handleLoad}\n          onError={handleError}\n          {...props}\n        />\n        {!imageLoaded && (\n          <View style={[StyleSheet.absoluteFillObject, { backgroundColor: '#f0f0f0', justifyContent: 'center', alignItems: 'center' }]}>\n            <ActivityIndicator size=\"small\" color=\"#999\" />\n          </View>\n        )}\n      </View>\n    );\n  });\n  \n  // Animaciones optimizadas\n  static createOptimizedAnimation(config: AnimationConfig): Animated.CompositeAnimation {\n    const { type, toValue, duration, useNativeDriver = true } = config;\n    \n    const animatedValue = new Animated.Value(config.fromValue || 0);\n    \n    let animation: Animated.CompositeAnimation;\n    \n    switch (type) {\n      case 'timing':\n        animation = Animated.timing(animatedValue, {\n          toValue,\n          duration: duration || this.UI_CONFIG.ANIMATION_DURATION.NORMAL,\n          useNativeDriver,\n          easing: Easing.out(Easing.cubic)\n        });\n        break;\n        \n      case 'spring':\n        animation = Animated.spring(animatedValue, {\n          toValue,\n          useNativeDriver,\n          tension: 100,\n          friction: 8\n        });\n        break;\n        \n      default:\n        animation = Animated.timing(animatedValue, {\n          toValue,\n          duration: this.UI_CONFIG.ANIMATION_DURATION.NORMAL,\n          useNativeDriver\n        });\n    }\n    \n    return animation;\n  }\n  \n  // Gestor de prioridades de renderizado\n  static scheduleRender(callback: () => void, priority: 'high' | 'normal' | 'low' = 'normal'): void {\n    const delay = {\n      high: 0,\n      normal: this.UI_CONFIG.RENDER_OPTIMIZATION.RENDER_TIMEOUT,\n      low: this.UI_CONFIG.RENDER_OPTIMIZATION.RENDER_TIMEOUT * 2\n    }[priority];\n    \n    if (delay === 0) {\n      // Alta prioridad - ejecutar inmediatamente\n      callback();\n    } else {\n      // Usar InteractionManager para operaciones de baja prioridad\n      InteractionManager.runAfterInteractions(() => {\n        setTimeout(callback, delay);\n      });\n    }\n  }\n  \n  // Optimizador de estilos\n  static optimizeStyles(styles: any): any {\n    // Crear StyleSheet para mejor rendimiento\n    return StyleSheet.create(styles);\n  }\n  \n  // Detector de rendimiento de componentes\n  static withPerformanceMonitoring<P extends object>(\n    Component: React.ComponentType<P>,\n    componentName: string\n  ): React.ComponentType<P> {\n    return React.memo((props: P) => {\n      const renderStartTime = useRef<number>();\n      const [renderCount, setRenderCount] = useState(0);\n      \n      // Medir tiempo de renderizado\n      renderStartTime.current = performance.now();\n      \n      useEffect(() => {\n        const renderTime = performance.now() - (renderStartTime.current || 0);\n        setRenderCount(prev => prev + 1);\n        \n        if (renderTime > 16) { // Más de 16ms (60 FPS)\n          console.warn(`⚠️ Slow render detected in ${componentName}: ${renderTime.toFixed(2)}ms (render #${renderCount})`);\n        }\n        \n        // Log estadísticas cada 10 renders\n        if (renderCount % 10 === 0) {\n          console.log(`📊 ${componentName} performance: ${renderCount} renders, last: ${renderTime.toFixed(2)}ms`);\n        }\n      });\n      \n      return <Component {...props} />;\n    });\n  }\n}\n\n// Interfaces para optimización de UI\ninterface AnimationConfig {\n  type: 'timing' | 'spring';\n  toValue: number;\n  fromValue?: number;\n  duration?: number;\n  useNativeDriver?: boolean;\n}\n\n// Hooks personalizados para optimización\nexport const useOptimizedCallback = <T extends (...args: any[]) => any>(\n  callback: T,\n  deps: React.DependencyList\n): T => {\n  return useCallback(callback, deps);\n};\n\nexport const useOptimizedMemo = <T>(\n  factory: () => T,\n  deps: React.DependencyList\n): T => {\n  return useMemo(factory, deps);\n};\n\nexport const useOptimizedEffect = (\n  effect: React.EffectCallback,\n  deps: React.DependencyList,\n  priority: 'high' | 'normal' | 'low' = 'normal'\n): void => {\n  useEffect(() => {\n    if (priority === 'high') {\n      return effect();\n    } else {\n      const cleanup = InteractionManager.runAfterInteractions(() => {\n        return effect();\n      });\n      \n      return () => {\n        cleanup.cancel();\n      };\n    }\n  }, deps);\n};\n\n// Utilidades de throttle y debounce\nfunction throttle<T extends (...args: any[]) => any>(\n  func: T,\n  delay: number\n): (...args: Parameters<T>) => void {\n  let timeoutId: NodeJS.Timeout | null = null;\n  let lastExecTime = 0;\n  \n  return (...args: Parameters<T>) => {\n    const currentTime = Date.now();\n    \n    if (currentTime - lastExecTime > delay) {\n      func(...args);\n      lastExecTime = currentTime;\n    } else {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      \n      timeoutId = setTimeout(() => {\n        func(...args);\n        lastExecTime = Date.now();\n      }, delay - (currentTime - lastExecTime));\n    }\n  };\n}\n\nfunction debounce<T extends (...args: any[]) => any>(\n  func: T,\n  delay: number\n): (...args: Parameters<T>) => void {\n  let timeoutId: NodeJS.Timeout | null = null;\n  \n  return (...args: Parameters<T>) => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    \n    timeoutId = setTimeout(() => {\n      func(...args);\n    }, delay);\n  };\n}\n```\n\n## Performance Monitoring\n\n### Comprehensive Performance Monitor\n\n```typescript\n// Monitor integral de rendimiento\nexport class PerformanceMonitor {\n  private static instance: PerformanceMonitor;\n  private metrics: PerformanceMetrics = {\n    appStartTime: Date.now(),\n    screenTransitions: [],\n    apiCalls: [],\n    renderTimes: [],\n    memoryUsage: [],\n    batteryUsage: [],\n    networkUsage: []\n  };\n  \n  private readonly MONITORING_CONFIG = {\n    MAX_STORED_METRICS: 1000,\n    SAMPLING_INTERVAL: 30000,     // 30 segundos\n    REPORT_INTERVAL: 300000,      // 5 minutos\n    PERFORMANCE_THRESHOLDS: {\n      SLOW_SCREEN_TRANSITION: 1000,  // 1 segundo\n      SLOW_API_CALL: 5000,          // 5 segundos\n      SLOW_RENDER: 16,              // 16ms (60 FPS)\n      HIGH_MEMORY_USAGE: 100 * 1024 * 1024, // 100MB\n      LOW_BATTERY_THRESHOLD: 0.2     // 20%\n    }\n  };\n  \n  private constructor() {\n    this.initializeMonitoring();\n  }\n  \n  static getInstance(): PerformanceMonitor {\n    if (!this.instance) {\n      this.instance = new PerformanceMonitor();\n    }\n    return this.instance;\n  }\n  \n  private initializeMonitoring(): void {\n    // Configurar muestreo periódico\n    setInterval(() => {\n      this.collectSystemMetrics();\n    }, this.MONITORING_CONFIG.SAMPLING_INTERVAL);\n    \n    // Configurar reportes periódicos\n    setInterval(() => {\n      this.generatePerformanceReport();\n    }, this.MONITORING_CONFIG.REPORT_INTERVAL);\n    \n    // Configurar listeners de eventos\n    this.setupEventListeners();\n  }\n  \n  private setupEventListeners(): void {\n    // Listener para transiciones de pantalla\n    const navigationRef = NavigationContainer.ref;\n    if (navigationRef) {\n      navigationRef.addListener('state', (e) => {\n        this.trackScreenTransition(e.data.state);\n      });\n    }\n    \n    // Listener para advertencias de memoria\n    DeviceEventEmitter.addListener('memoryWarning', () => {\n      this.recordMemoryWarning();\n    });\n  }\n  \n  private async collectSystemMetrics(): Promise<void> {\n    try {\n      // Recopilar métricas de memoria\n      const memoryUsage = await this.getMemoryUsage();\n      this.recordMemoryUsage(memoryUsage);\n      \n      // Recopilar métricas de batería\n      const batteryLevel = await DeviceInfo.getBatteryLevel();\n      this.recordBatteryUsage(batteryLevel);\n      \n      // Recopilar métricas de red\n      const networkState = await NetInfo.fetch();\n      this.recordNetworkUsage(networkState);\n      \n    } catch (error) {\n      console.error('Failed to collect system metrics:', error);\n    }\n  }\n  \n  private async getMemoryUsage(): Promise<number> {\n    try {\n      return await DeviceInfo.getUsedMemory();\n    } catch {\n      return 0;\n    }\n  }\n  \n  // API pública para tracking\n  trackScreenTransition(screenName: string, startTime?: number): void {\n    const transitionTime = Date.now() - (startTime || Date.now());\n    \n    const transition: ScreenTransition = {\n      screenName,\n      timestamp: Date.now(),\n      transitionTime\n    };\n    \n    this.metrics.screenTransitions.push(transition);\n    \n    // Verificar si es una transición lenta\n    if (transitionTime > this.MONITORING_CONFIG.PERFORMANCE_THRESHOLDS.SLOW_SCREEN_TRANSITION) {\n      console.warn(`🐌 Slow screen transition to ${screenName}: ${transitionTime}ms`);\n    }\n    \n    this.trimMetricsArray(this.metrics.screenTransitions);\n  }\n  \n  trackApiCall(endpoint: string, method: string, duration: number, success: boolean): void {\n    const apiCall: ApiCall = {\n      endpoint,\n      method,\n      duration,\n      success,\n      timestamp: Date.now()\n    };\n    \n    this.metrics.apiCalls.push(apiCall);\n    \n    // Verificar si es una llamada lenta\n    if (duration > this.MONITORING_CONFIG.PERFORMANCE_THRESHOLDS.SLOW_API_CALL) {\n      console.warn(`🐌 Slow API call: ${method} ${endpoint} took ${duration}ms`);\n    }\n    \n    this.trimMetricsArray(this.metrics.apiCalls);\n  }\n  \n  trackRenderTime(componentName: string, renderTime: number): void {\n    const render: RenderTime = {\n      componentName,\n      renderTime,\n      timestamp: Date.now()\n    };\n    \n    this.metrics.renderTimes.push(render);\n    \n    // Verificar si es un render lento\n    if (renderTime > this.MONITORING_CONFIG.PERFORMANCE_THRESHOLDS.SLOW_RENDER) {\n      console.warn(`🐌 Slow render: ${componentName} took ${renderTime.toFixed(2)}ms`);\n    }\n    \n    this.trimMetricsArray(this.metrics.renderTimes);\n  }\n  \n  private recordMemoryUsage(usage: number): void {\n    const memoryMetric: MemoryUsage = {\n      usage,\n      timestamp: Date.now()\n    };\n    \n    this.metrics.memoryUsage.push(memoryMetric);\n    \n    // Verificar uso alto de memoria\n    if (usage > this.MONITORING_CONFIG.PERFORMANCE_THRESHOLDS.HIGH_MEMORY_USAGE) {\n      console.warn(`🧠 High memory usage detected: ${this.formatBytes(usage)}`);\n    }\n    \n    this.trimMetricsArray(this.metrics.memoryUsage);\n  }\n  \n  private recordBatteryUsage(level: number): void {\n    const batteryMetric: BatteryUsage = {\n      level,\n      timestamp: Date.now()\n    };\n    \n    this.metrics.batteryUsage.push(batteryMetric);\n    \n    // Verificar batería baja\n    if (level < this.MONITORING_CONFIG.PERFORMANCE_THRESHOLDS.LOW_BATTERY_THRESHOLD) {\n      console.warn(`🔋 Low battery detected: ${(level * 100).toFixed(0)}%`);\n    }\n    \n    this.trimMetricsArray(this.metrics.batteryUsage);\n  }\n  \n  private recordNetworkUsage(networkState: any): void {\n    const networkMetric: NetworkUsage = {\n      isConnected: networkState.isConnected,\n      type: networkState.type,\n      effectiveType: networkState.details?.effectiveType,\n      timestamp: Date.now()\n    };\n    \n    this.metrics.networkUsage.push(networkMetric);\n    this.trimMetricsArray(this.metrics.networkUsage);\n  }\n  \n  private recordMemoryWarning(): void {\n    console.warn('📱 Memory warning received from system');\n    \n    // Registrar advertencia en métricas\n    this.recordMemoryUsage(this.MONITORING_CONFIG.PERFORMANCE_THRESHOLDS.HIGH_MEMORY_USAGE);\n  }\n  \n  private trimMetricsArray<T>(array: T[]): void {\n    if (array.length > this.MONITORING_CONFIG.MAX_STORED_METRICS) {\n      array.splice(0, array.length - this.MONITORING_CONFIG.MAX_STORED_METRICS);\n    }\n  }\n  \n  private generatePerformanceReport(): void {\n    const report = this.getPerformanceReport();\n    \n    console.log('📊 Performance Report:');\n    console.log(`  App Uptime: ${this.formatDuration(Date.now() - this.metrics.appStartTime)}`);\n    console.log(`  Screen Transitions: ${report.screenTransitions.total} (avg: ${report.screenTransitions.averageTime.toFixed(0)}ms)`);\n    console.log(`  API Calls: ${report.apiCalls.total} (success: ${(report.apiCalls.successRate * 100).toFixed(1)}%)`);\n    console.log(`  Slow Renders: ${report.renderTimes.slowRenders}`);\n    console.log(`  Memory Usage: ${this.formatBytes(report.memoryUsage.current)} (peak: ${this.formatBytes(report.memoryUsage.peak)})`);\n    console.log(`  Battery Level: ${(report.batteryUsage.current * 100).toFixed(0)}%`);\n  }\n  \n  getPerformanceReport(): PerformanceReport {\n    const now = Date.now();\n    const oneHourAgo = now - (60 * 60 * 1000);\n    \n    // Filtrar métricas de la última hora\n    const recentScreenTransitions = this.metrics.screenTransitions.filter(t => t.timestamp > oneHourAgo);\n    const recentApiCalls = this.metrics.apiCalls.filter(a => a.timestamp > oneHourAgo);\n    const recentRenderTimes = this.metrics.renderTimes.filter(r => r.timestamp > oneHourAgo);\n    const recentMemoryUsage = this.metrics.memoryUsage.filter(m => m.timestamp > oneHourAgo);\n    const recentBatteryUsage = this.metrics.batteryUsage.filter(b => b.timestamp > oneHourAgo);\n    \n    return {\n      appUptime: now - this.metrics.appStartTime,\n      \n      screenTransitions: {\n        total: recentScreenTransitions.length,\n        averageTime: recentScreenTransitions.length > 0 \n          ? recentScreenTransitions.reduce((sum, t) => sum + t.transitionTime, 0) / recentScreenTransitions.length\n          : 0,\n        slowTransitions: recentScreenTransitions.filter(t => \n          t.transitionTime > this.MONITORING_CONFIG.PERFORMANCE_THRESHOLDS.SLOW_SCREEN_TRANSITION\n        ).length\n      },\n      \n      apiCalls: {\n        total: recentApiCalls.length,\n        successRate: recentApiCalls.length > 0\n          ? recentApiCalls.filter(a => a.success).length / recentApiCalls.length\n          : 1,\n        averageLatency: recentApiCalls.length > 0\n          ? recentApiCalls.reduce((sum, a) => sum + a.duration, 0) / recentApiCalls.length\n          : 0,\n        slowCalls: recentApiCalls.filter(a => \n          a.duration > this.MONITORING_CONFIG.PERFORMANCE_THRESHOLDS.SLOW_API_CALL\n        ).length\n      },\n      \n      renderTimes: {\n        total: recentRenderTimes.length,\n        averageTime: recentRenderTimes.length > 0\n          ? recentRenderTimes.reduce((sum, r) => sum + r.renderTime, 0) / recentRenderTimes.length\n          : 0,\n        slowRenders: recentRenderTimes.filter(r => \n          r.renderTime > this.MONITORING_CONFIG.PERFORMANCE_THRESHOLDS.SLOW_RENDER\n        ).length\n      },\n      \n      memoryUsage: {\n        current: recentMemoryUsage.length > 0 ? recentMemoryUsage[recentMemoryUsage.length - 1].usage : 0,\n        peak: recentMemoryUsage.length > 0 ? Math.max(...recentMemoryUsage.map(m => m.usage)) : 0,\n        average: recentMemoryUsage.length > 0\n          ? recentMemoryUsage.reduce((sum, m) => sum + m.usage, 0) / recentMemoryUsage.length\n          : 0\n      },\n      \n      batteryUsage: {\n        current: recentBatteryUsage.length > 0 ? recentBatteryUsage[recentBatteryUsage.length - 1].level : 1,\n        startLevel: recentBatteryUsage.length > 0 ? recentBatteryUsage[0].level : 1,\n        consumption: recentBatteryUsage.length > 1 \n          ? recentBatteryUsage[0].level - recentBatteryUsage[recentBatteryUsage.length - 1].level\n          : 0\n      }\n    };\n  }\n  \n  private formatBytes(bytes: number): string {\n    if (bytes === 0) return '0 Bytes';\n    \n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n  \n  private formatDuration(ms: number): string {\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    \n    if (hours > 0) {\n      return `${hours}h ${minutes % 60}m`;\n    } else if (minutes > 0) {\n      return `${minutes}m ${seconds % 60}s`;\n    } else {\n      return `${seconds}s`;\n    }\n  }\n  \n  // API pública\n  getMetrics(): PerformanceMetrics {\n    return { ...this.metrics };\n  }\n  \n  clearMetrics(): void {\n    this.metrics = {\n      appStartTime: Date.now(),\n      screenTransitions: [],\n      apiCalls: [],\n      renderTimes: [],\n      memoryUsage: [],\n      batteryUsage: [],\n      networkUsage: []\n    };\n  }\n  \n  exportMetrics(): string {\n    return JSON.stringify(this.getPerformanceReport(), null, 2);\n  }\n}\n\n// Interfaces para métricas de rendimiento\ninterface PerformanceMetrics {\n  appStartTime: number;\n  screenTransitions: ScreenTransition[];\n  apiCalls: ApiCall[];\n  renderTimes: RenderTime[];\n  memoryUsage: MemoryUsage[];\n  batteryUsage: BatteryUsage[];\n  networkUsage: NetworkUsage[];\n}\n\ninterface ScreenTransition {\n  screenName: string;\n  timestamp: number;\n  transitionTime: number;\n}\n\ninterface ApiCall {\n  endpoint: string;\n  method: string;\n  duration: number;\n  success: boolean;\n  timestamp: number;\n}\n\ninterface RenderTime {\n  componentName: string;\n  renderTime: number;\n  timestamp: number;\n}\n\ninterface MemoryUsage {\n  usage: number;\n  timestamp: number;\n}\n\ninterface BatteryUsage {\n  level: number;\n  timestamp: number;\n}\n\ninterface NetworkUsage {\n  isConnected: boolean;\n  type: string;\n  effectiveType?: string;\n  timestamp: number;\n}\n\ninterface PerformanceReport {\n  appUptime: number;\n  screenTransitions: {\n    total: number;\n    averageTime: number;\n    slowTransitions: number;\n  };\n  apiCalls: {\n    total: number;\n    successRate: number;\n    averageLatency: number;\n    slowCalls: number;\n  };\n  renderTimes: {\n    total: number;\n    averageTime: number;\n    slowRenders: number;\n  };\n  memoryUsage: {\n    current: number;\n    peak: number;\n    average: number;\n  };\n  batteryUsage: {\n    current: number;\n    startLevel: number;\n    consumption: number;\n  };\n}\n```\n\n---\n\n**Última Actualización**: Enero 2025  \n**Versión**: 1.0  \n**Mantenido por**: Equipo de Desarrollo CrediBowpi"